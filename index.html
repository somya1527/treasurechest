<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Treasure — White Ground + Resized Player (Per-chest Questions) — Fixed + Sakura &amp; Fireworks</title>
<style>
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:#061420;color:#eaf2ff}
  #app{display:flex;height:100vh}
  #left{flex:1; position:relative; overflow:hidden}
  canvas{display:block; width:100%; height:100%}
  #side{width:360px; padding:12px; background:linear-gradient(180deg,#071827,#052631); box-sizing:border-box}
  .pill{background:rgba(255,255,255,0.03); padding:8px 10px;border-radius:8px; display:inline-block; margin-right:6px}
  .small{font-size:13px;color:#98b9cf}
  .panel{background:rgba(255,255,255,0.02); padding:10px; border-radius:10px; margin-bottom:12px}
  button{padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);color:inherit;cursor:pointer}
  .inv{display:flex; gap:6px; flex-wrap:wrap}
  .inv-item{background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:6px; font-weight:800}
  textarea{font-family:inherit; font-size:13px; color:#eaf2ff; background:transparent; border:1px solid rgba(255,255,255,0.03); width:100%; box-sizing:border-box}
  .chest-area{display:grid; grid-template-columns:1fr; gap:8px; max-height:360px; overflow:auto; padding-right:6px}
  .chest-card{background:rgba(255,255,255,0.02); padding:8px; border-radius:8px}
  .chest-header{display:flex;justify-content:space-between;align-items:center;gap:8px}
  .qa-row{display:flex; gap:6px}
  .qa-row input{flex:1; padding:6px; border-radius:6px; background:transparent; border:1px solid rgba(255,255,255,0.03); color:inherit}
  .small-muted{font-size:12px;color:#7ea6c9}
  .admin-badge{display:inline-block;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.04);font-weight:800}

  /* Popup modal styles */
  .birthday-overlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.75);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:10000;
  }
  .birthday-box{
    width:clamp(320px, 80vw, 980px);
    max-height:90vh;
    overflow:auto;
    background:linear-gradient(180deg,#082a30,#06343a);
    border-radius:14px;
    padding:22px;
    box-shadow:0 10px 40px rgba(0,0,0,0.6);
    color:#fff;
    text-align:center;
  }
  .birthday-text{
    font-weight:900;
    font-size:20px;
    line-height:1.15;
    white-space:pre-wrap;
    margin-bottom:18px;
    color:#ffd27a;
  }
  .birthday-sub{
    font-size:14px;
    color:#e8f9ff;
    margin-bottom:16px;
  }
  .birthday-close{
    display:inline-block;
    padding:10px 18px;
    border-radius:10px;
    background:rgba(255,255,255,0.06);
    border:1px solid rgba(255,255,255,0.06);
    cursor:pointer;
    font-weight:800;
  }

  /* simple floating hearts overlay (DOM) */
  .heart {
    position:fixed; pointer-events:none; z-index:9998; transform:translate(-50%,-50%); opacity:0.95; font-size:18px;
    text-shadow:0 6px 18px rgba(0,0,0,0.4);
  }

  /* chest number popup (DOM) */
  .chest-popup{
    position:fixed;
    pointer-events:none;
    z-index:99999;
    transform:translate(-50%,-120%);
    background:rgba(255,255,255,0.95);
    color:#06111a;
    font-weight:900;
    padding:8px 12px;
    border-radius:10px;
    box-shadow:0 10px 30px rgba(0,0,0,0.45);
    min-width:44px;
    text-align:center;
    font-size:18px;
    display:none;
  }
  .chest-popup .num{font-size:22px;}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
    "three/": "https://unpkg.com/three@0.152.2/"
  }
}
</script>
</head>
<body>
  <!-- Birthday popup (shows immediately on load) -->
  <div id="birthdayPopup" class="birthday-overlay" aria-hidden="false" role="dialog">
    <div class="birthday-box" role="document">
      <div class="birthday-text" id="birthdayText">
HAAAAAAAAAAPPPPPPPPPPPPPPPPPPYYYYYYYYYYYYYYYY BBBBBBBBIIIIIIIIIIIIIRRRRRRRRRRRRRRRRRRRRRTTTTTTTTTTTTHHHHHHHHHDDDDDDDDDDDDDDAAAAAAAAAAAAYYYYYYYYYYYY DOOOOOOOBBBIIIIIIIIIII!!!!!!
Now, there are 20 chests in this small game I made, you cannot open any chest at random, all of them are numbered, BUTT(yours) THEY ARE PASSWORD PROTECTED, if the question has options jaise A or B, just write the letter A or B as the answer, not the entire sentence ok? I LAVE YYOOUUU!! ( p.s. its not alot pr just know I made it with love.)
      </div>
      <div class="birthday-sub">(Click below to close — message shown on load)</div>
      <button id="birthdayClose" class="birthday-close">Close</button>
    </div>
  </div>

  <div id="app">
    <div id="left">
      <div style="position:absolute;left:12px;top:12px;z-index:60">
        <span class="pill">WASD / Arrow — Move</span>
        <span class="pill">Space — Jump</span>
        <span class="pill">Right-drag — Rotate camera</span>
      </div>

      <div style="position:absolute; right:12px; top:12px; z-index:60">
        <span class="pill">Found: <span id="found">0</span>/20</span>
        <span class="pill" id="nextPill">Next: <span id="next">1</span></span>
      </div>

      <div id="tooltip"></div>
      <canvas id="glcanvas"></canvas>
    </div>

    <aside id="side">
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>Player & Letters</strong><div class="small">20 chests — each chest has its own textarea and a Q & A. Changes are saved with the Save button (or auto-saved when you open a chest).</div></div>
          <div><span id="adminBadge" class="admin-badge" style="display:none">ADMIN</span><button id="copyHTML">Copy HTML</button></div>
        </div>

        <div style="margin-top:12px">
          <div class="small">Letters for chests — each chest has its own textarea and a Q & A. Use the Save button to persist (admin only).</div>
          <div class="chest-area" id="chestArea"></div>
        </div>

        <div style="display:flex; gap:8px; margin-top:8px">
          <button id="saveBtn">Save</button>
          <button id="resetBtn">Reset progress</button>
          <button id="regenBtn">Regenerate world</button>
        </div>

        <div id="readOnlyNote" class="small" style="margin-top:8px; display:none">You are in read-only mode. Add <code>?admin=dobbi</code> to the URL to enable editing.</div>
      </div>

      <div class="panel">
        <strong>Cinematic / Dialog</strong>
        <div class="small">Dialog box shows opened letters and typewriter-style dialog. (TTS option removed)</div>
        <div style="margin-top:10px">
          <div id="dialogBox"></div>
        </div>
      </div>

      <div class="panel small">
        Right-drag rotates camera yaw; W moves toward camera-facing forward. World is now smaller for easier play.
      </div>
    </aside>
  </div>

  <!-- chest number popup (DOM) -->
  <div id="chestPopup" class="chest-popup"><span class="num">1</span></div>

  <script type="module">
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
  import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';

  // simple logger (no on-screen log)
  function slog(msg){ console.log(msg); }
  window.addEventListener('error', e => { slog('Error: ' + (e.message || e)); });
  window.addEventListener('unhandledrejection', e => { slog('Rejection: ' + (e.reason || e)); });

  // Admin check — enable admin editing only when URL has ?admin=dobbi
  const params = new URLSearchParams(window.location.search);
  const isAdmin = params.get('admin') === 'dobbi';

  // DOM refs
  const canvas = document.getElementById('glcanvas');
  const tooltipEl = document.getElementById('tooltip');
  const foundEl = document.getElementById('found');
  const nextEl = document.getElementById('next');
  const nextPill = document.getElementById('nextPill');
  const chestArea = document.getElementById('chestArea');
  const saveBtn = document.getElementById('saveBtn');
  const resetBtn = document.getElementById('resetBtn');
  const regenBtn = document.getElementById('regenBtn');
  const dialogBox = document.getElementById('dialogBox');
  const copyHTML = document.getElementById('copyHTML');
  const chestPopup = document.getElementById('chestPopup');
  const adminBadge = document.getElementById('adminBadge');
  const readOnlyNote = document.getElementById('readOnlyNote');

  // renderer & scene
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xbfdfff); // soft sky

  const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 5000);
  camera.position.set(0, 320, 700);

  // camera yaw controls
  let cameraYaw = Math.PI * 0.25;
  let cameraPitch = -0.35;
  let isDragging = false;
  let lastPointerX = 0, lastPointerY = 0;
  const canvasEl = renderer.domElement;
  canvasEl.addEventListener('contextmenu', e => e.preventDefault());
  canvasEl.addEventListener('pointerdown', (e) => {
    if(e.button === 2){ isDragging = true; lastPointerX = e.clientX; lastPointerY = e.clientY; canvasEl.setPointerCapture(e.pointerId); }
  });
  canvasEl.addEventListener('pointerup', (e) => { if(e.button === 2){ isDragging = false; try{ canvasEl.releasePointerCapture(e.pointerId); }catch(_){} }});
  canvasEl.addEventListener('pointermove', (e) => {
    if(!isDragging) return;
    const dx = e.clientX - lastPointerX; const dy = e.clientY - lastPointerY;
    lastPointerX = e.clientX; lastPointerY = e.clientY;
    cameraYaw -= dx * 0.005;
    cameraPitch = Math.max(-0.6, Math.min(0.6, cameraPitch - dy * 0.003));
  });
  // wheel zoom
  let cameraDistanceDefault = 420;
  canvasEl.addEventListener('wheel', (e) => { cameraDistanceDefault = Math.max(60, Math.min(900, cameraDistanceDefault + e.deltaY * 0.1)); e.preventDefault(); }, { passive:false });

  // lights (tweaked for white ground)
  const hemi = new THREE.HemisphereLight(0xffffee, 0x888888, 1.1); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(200,400,100); dir.castShadow = true; scene.add(dir);

  // ground (now green) — world made smaller
  const WORLD_W = 2000, WORLD_H = 1600;
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(WORLD_W, WORLD_H, 8,8),
    new THREE.MeshStandardMaterial({ color:0x66bb6a, roughness:0.95, metalness:0 })
  );
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

  // player & placeholder (resized)
  const player = new THREE.Group(); player.position.set(0,40,0); player.scale.set(5,5,5); scene.add(player);
  let placeholder = null;
  (function makePlaceholder(){
    placeholder = new THREE.Group();
    const torso = new THREE.Mesh(new THREE.BoxGeometry(18,28,12), new THREE.MeshStandardMaterial({ color:0xec4899 }));
    torso.position.y = 28; placeholder.add(torso);
    const head = new THREE.Mesh(new THREE.SphereGeometry(9,12,8), new THREE.MeshStandardMaterial({ color:0xffdcc3 }));
    head.position.y = 48; placeholder.add(head);
    const hair = new THREE.Mesh(new THREE.BoxGeometry(20,18,18), new THREE.MeshStandardMaterial({ color:0x2b1b0f }));
    hair.position.set(0,44,-6); placeholder.add(hair);
    player.add(placeholder);
  })();

  // SAKURA TREES - lovey dovey additions
  const sakuraGroup = new THREE.Group(); scene.add(sakuraGroup);
  function makeSakuraTree(){
    const g = new THREE.Group();
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(2,3,28,8), new THREE.MeshStandardMaterial({ color:0x5a3b2b }));
    trunk.position.y = 14; g.add(trunk);
    const canopy = new THREE.Group();
    for(let i=0;i<18;i++){
      const s = new THREE.Mesh(new THREE.SphereGeometry(6.5,6,6), new THREE.MeshStandardMaterial({ color: 0xffb6c1, flatShading:true }));
      const ang = Math.random()*Math.PI*2; const r = 6 + Math.random()*18; const y = 8 + Math.random()*22;
      s.position.set(Math.cos(ang)*r, y, Math.sin(ang)*r);
      s.scale.setScalar(0.7 + Math.random()*1.2);
      canopy.add(s);
    }
    canopy.position.y = 28; g.add(canopy);
    return g;
  }

  function placeSakuraTrees(count=40){
    while(sakuraGroup.children.length) sakuraGroup.remove(sakuraGroup.children[0]);
    const margin = 220;
    for(let i=0;i<count;i++){
      let x = (Math.random()-0.5)*(WORLD_W - margin*2);
      let z = (Math.random()-0.5)*(WORLD_H - margin*2);
      if(Math.hypot(x,z) < 220){ x += Math.sign(x||1)*220; z += Math.sign(z||1)*220; }
      const t = makeSakuraTree();
      t.position.set(x,0,z);
      t.scale.setScalar(1.0 + Math.random()*0.9);
      sakuraGroup.add(t);
    }
  }
  placeSakuraTrees(48);

  // chests (open-world placement, no barriers)
  let chests = [];
  function makeLabelPlane(txt){
    const c = document.createElement('canvas'); c.width=256; c.height=256; const ctx=c.getContext('2d');
    ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,c.width,c.height);
    ctx.fillStyle='#06111a'; ctx.font='bold 120px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(txt, c.width/2, c.height/2);
    const tex = new THREE.CanvasTexture(c); return new THREE.Mesh(new THREE.PlaneGeometry(16,16), new THREE.MeshBasicMaterial({ map:tex, transparent:true }));
  }
  function placeWorld(){
    chests.forEach(c=>scene.remove(c.group)); chests=[];
    const margin = 200;
    for(let i=1;i<=20;i++){
      let placed=false, tries=0;
      while(!placed && tries<5000){
        const x = (Math.random()-0.5)*(WORLD_W - margin*2);
        const z = (Math.random()-0.5)*(WORLD_H - margin*2);
        if(Math.hypot(x,z) < 200){ tries++; continue; }
        let ok=true; for(const c of chests) if(Math.hypot(c.x-x,c.z-z) < 180){ ok=false; break; }
        if(!ok){ tries++; continue; }
        const g = new THREE.Group();
        const base = new THREE.Mesh(new THREE.BoxGeometry(18,12,14), new THREE.MeshStandardMaterial({ color:0x6b3b2a })); base.position.y=6; g.add(base);
        const lid = new THREE.Mesh(new THREE.BoxGeometry(20,8,16), new THREE.MeshStandardMaterial({ color:0xf59e0b })); lid.position.y=14; g.add(lid);
        const lab = makeLabelPlane(String(i)); lab.position.set(0,8,8.9); g.add(lab);
        g.position.set(x,0,z); scene.add(g);
        chests.push({ id:i, group:g, lid, label:lab, opened:false, collected:false, x, z, question:'What is 2 + 2?', answer:'4' });
        placed=true;
      }
    }
  }
  placeWorld();

  // particles
  let particlePool = []; let particles = [];
  function ensureParticleMeshes(n){ while(particlePool.length < n){ const s = new THREE.Mesh(new THREE.SphereGeometry(2,6,6), new THREE.MeshStandardMaterial({ color:0xffd27a })); s.castShadow=false; s.receiveShadow=false; scene.add(s); particlePool.push(s); } }
  function spawnParticlesAt(x, z, count=12){ for(let i=0;i<count;i++){ const angle = Math.random()*Math.PI*2; particles.push({ pos:new THREE.Vector3(x,24+Math.random()*20,z), vel:new THREE.Vector3(Math.cos(angle)*(30+Math.random()*80),40+Math.random()*120,Math.sin(angle)*(30+Math.random()*80)), life:0.8+Math.random()*0.8, color: Math.random()>0.5?0xffd27a:0xff9f76 }); } }

  // LOVELY HEART PARTICLES (ambient)
  let heartPool = []; let heartParticles = [];
  function ensureHeartMeshes(n){ while(heartPool.length < n){ const geom = new THREE.SphereGeometry(2.2,6,6); const mat = new THREE.MeshStandardMaterial({ color:0xff6fbf, transparent:true, opacity:0.95 }); const m = new THREE.Mesh(geom, mat); m.castShadow=false; m.receiveShadow=false; scene.add(m); heartPool.push(m); } }
  function spawnHeart(x,y,z, velY=20){ heartParticles.push({ pos:new THREE.Vector3(x,y,z), vel:new THREE.Vector3((Math.random()-0.5)*8, velY+(Math.random()*20), (Math.random()-0.5)*8), life:2 + Math.random()*3, scale:0.8+Math.random()*1.2 }); }
  setInterval(()=>{ if(Math.random()<0.6) spawnHeart(player.position.x + (Math.random()-0.5)*60, player.position.y + 30 + Math.random()*30, player.position.z + (Math.random()-0.5)*60, 20); }, 800);

  // fireworks system
  let fireworksActive = false;
  let fireworkPool = [];
  function ensureFireworkMeshes(n){ while(fireworkPool.length < n){ const s = new THREE.Mesh(new THREE.SphereGeometry(1.8,6,6), new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0xffffff })); s.castShadow=false; s.receiveShadow=false; scene.add(s); fireworkPool.push(s); } }
  function triggerFireworks(duration=4500){ if(fireworksActive) return; fireworksActive = true; const started = performance.now(); ensureFireworkMeshes(200);
    const interval = setInterval(()=>{
      const cx = player.position.x + (Math.random()-0.5)*60;
      const cz = player.position.z + (Math.random()-0.5)*60;
      const cy = player.position.y + 200 + Math.random()*120;
      const pieces = 30 + Math.floor(Math.random()*40);
      for(let i=0;i<pieces;i++){
        const ang = Math.random()*Math.PI*2; const elev = Math.random()*Math.PI*0.8; const speed = 80 + Math.random()*240;
        const vx = Math.cos(ang)*Math.sin(elev)*speed; const vz = Math.sin(ang)*Math.sin(elev)*speed; const vy = Math.cos(elev)*speed;
        particles.push({ pos:new THREE.Vector3(cx, cy, cz), vel:new THREE.Vector3(vx, vy, vz), life:1.1 + Math.random()*1.6, color: [0xff3d6b,0xffb36b,0xfff36b,0x6bafff][Math.floor(Math.random()*4)] });
      }
    }, 300);
    const heartBurst = setInterval(()=>{ for(let i=0;i<12;i++){ createDOMHeartBurst(); } }, 400);
    setTimeout(()=>{ clearInterval(interval); clearInterval(heartBurst); fireworksActive = false; }, duration);
  }

  function createDOMHeartBurst(){ const el = document.createElement('div'); el.className='heart'; el.textContent='❤'; document.body.appendChild(el); const x = window.innerWidth * (0.2 + Math.random()*0.6); const y = window.innerHeight * (0.5 + Math.random()*0.4);
    el.style.left = x + 'px'; el.style.top = y + 'px'; el.style.fontSize = (12 + Math.random()*28) + 'px'; el.style.opacity = '0.95'; const dx = (Math.random()-0.5)*200; const dy = -200 - Math.random()*200; el.animate([{ transform:`translate(${0}px, ${0}px)`, opacity:1 },{ transform:`translate(${dx}px, ${dy}px) rotate(${Math.random()*180}deg)`, opacity:0 }], { duration: 1800 + Math.random()*1000, easing:'cubic-bezier(.2,.7,.2,1)' }); setTimeout(()=>el.remove(), 2200); }

  // persistence & UI
  let letters = Array.from({length:20}, (_,i)=>('Letter ' + (i+1) + ' — write your long letter here.'));
  let qa = Array.from({length:20}, (_,i)=>({ question: `What is ${i+2} + ${i+1}?`, answer: String((i+2)+(i+1)) }));
  let foundCount = 0;
  let nextChest = 1;
  const STORAGE_KEY = 'treasure_camfixed_small_perchest_q_v1_sakura';

  function createChestTextareas(){
    chestArea.innerHTML = '';
    for(let i=0;i<20;i++){
      const card = document.createElement('div'); card.className='chest-card';
      const header = document.createElement('div'); header.className='chest-header';
      const title = document.createElement('div'); title.textContent = `Chest ${i+1}`;
      const buttons = document.createElement('div');
      const openBtn = document.createElement('button'); openBtn.textContent='Teleport & Open'; openBtn.title='Teleport to chest and attempt to open it';
      openBtn.onclick = ()=>{ const c = chests.find(cc=>cc.id===i+1); if(c){ player.position.set(c.x, c.group.position.y + 40, c.z); interact(); } }
      const saveBtnLocal = document.createElement('button'); saveBtnLocal.textContent='Save'; saveBtnLocal.onclick = ()=>{ if(!isAdmin){ toast('Admin only'); return; } letters[i] = ta.value; qa[i].question = qIn.value; qa[i].answer = aIn.value; saveState(); refreshUI(); toast(`Saved chest ${i+1}`); };
      buttons.appendChild(openBtn);
      if(isAdmin) buttons.appendChild(saveBtnLocal);
      header.appendChild(title); header.appendChild(buttons);

      const ta = document.createElement('textarea'); ta.rows=4; ta.placeholder = `Letter for chest ${i+1} — paste long text here.`;
      const qLbl = document.createElement('div'); qLbl.className='small-muted'; qLbl.textContent = 'Question (shown before opening)';
      const qIn = document.createElement('input'); qIn.type='text'; qIn.placeholder='Question text';
      const aLbl = document.createElement('div'); aLbl.className='small-muted'; aLbl.textContent = 'Answer (case-insensitive)';
      const aIn = document.createElement('input'); aIn.type='text'; aIn.placeholder='Answer text';

      const qaRow = document.createElement('div'); qaRow.className='qa-row';
      qaRow.appendChild(qIn); qaRow.appendChild(aIn);

      card.appendChild(header);
      card.appendChild(ta);
      card.appendChild(qLbl);
      card.appendChild(qaRow);
      card.appendChild(aLbl);

      chestArea.appendChild(card);

      // populate from letters & qa arrays
      ta.value = letters[i] || '';
      qIn.value = qa[i] ? qa[i].question : '';
      aIn.value = qa[i] ? qa[i].answer : '';
      ta.dataset.index = String(i);
      qIn.dataset.index = String(i);
      aIn.dataset.index = String(i);

      // if not admin, make inputs read-only and hide local save
      if(!isAdmin){ ta.readOnly = true; qIn.readOnly = true; aIn.readOnly = true; }
    }
  }

  function saveState(){ if(!isAdmin){ slog('Attempted save prevented — not admin'); return; } try{ const st={ letters, qa, chests: chests.map(c=>({id:c.id, collected:c.collected})), foundCount, nextChest, player:{x:player.position.x, y:player.position.y, z:player.position.z} }; localStorage.setItem(STORAGE_KEY, JSON.stringify(st)); }catch(e){ console.warn(e); } }
  function loadState(){ try{ const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return false; const s = JSON.parse(raw); if(s.letters && Array.isArray(s.letters) && s.letters.length===20) letters=s.letters; if(s.qa && Array.isArray(s.qa) && s.qa.length===20) qa=s.qa; if(s.chests && s.chests.length===20){ setTimeout(()=>{ for(const sc of s.chests){ const f = chests.find(c=>c.id===sc.id); if(f && sc.collected){ f.collected=true; f.group.children[1].rotation.x=-0.9; } } refreshUI(); }, 40); } foundCount = s.foundCount || 0; nextChest = s.nextChest || 1; if(s.player && typeof s.player.x==='number') player.position.set(s.player.x, s.player.y, s.player.z); return true; }catch(e){ return false; } }

  function refreshUI(){ foundEl.textContent = foundCount; nextEl.textContent = nextChest; const cards = chestArea.querySelectorAll('.chest-card'); cards.forEach((card, idx) => {
      const ta = card.querySelector('textarea');
      const qIn = card.querySelectorAll('input')[0];
      const aIn = card.querySelectorAll('input')[1];
      if(ta) ta.value = letters[idx] || '';
      if(qIn) qIn.value = qa[idx] ? qa[idx].question : '';
      if(aIn) aIn.value = qa[idx] ? qa[idx].answer : '';
    }); }

  // top-level save button will copy textarea contents into letters[] and persist (admin-only)
  saveBtn.onclick = ()=>{ if(!isAdmin){ toast('Admin only'); return; } const cards = chestArea.querySelectorAll('.chest-card'); cards.forEach((card) => {
      const idx = Number(card.querySelector('textarea').dataset.index);
      letters[idx] = card.querySelector('textarea').value;
      qa[idx].question = card.querySelectorAll('input')[0].value;
      qa[idx].answer = card.querySelectorAll('input')[1].value;
    }); saveState(); refreshUI(); toast('Saved all letters & Q/A'); };

  resetBtn.onclick = ()=>{ if(!confirm('Reset progress?')) return; foundCount = 0; nextChest = 1; chests.forEach(c=>{ c.collected = false; c.opened = false; try{ if(c.group && c.group.children[1]) c.group.children[1].rotation.x = 0; }catch(_){} }); saveState(); refreshUI(); toast('Progress reset'); };
  regenBtn.onclick = ()=>{ if(!confirm('Regenerate world?')) return; chests.forEach(c=>{ try{ scene.remove(c.group); }catch(_){} }); chests=[]; placeWorld(); foundCount = 0; nextChest = 1; if(!qa || qa.length !== 20) qa = Array.from({length:20}, (_,i)=>({ question: `What is ${i+2} + ${i+1}?`, answer: String((i+2)+(i+1)) })); createChestTextareas(); refreshUI(); saveState(); toast('World regenerated'); };
  copyHTML.onclick = async ()=>{ try{ await navigator.clipboard.writeText(document.documentElement.outerHTML); toast('HTML copied'); }catch(e){ toast('copy failed'); } };

  function toast(msg, ms=1200){ const el = document.createElement('div'); el.textContent = msg; Object.assign(el.style,{position:'fixed',right:'18px',bottom:'18px',background:'rgba(0,0,0,0.7)',padding:'8px 12px',borderRadius:'8px',color:'#fff',zIndex:9999}); document.body.appendChild(el); setTimeout(()=>el.remove(), ms); }

  // movement & camera variables
  let velocity = new THREE.Vector3(0,0,0);
  let onGround = true;
  const GRAV = -2200;
  const MOVE_SPEED = 260;
  let walkTimer = 0;
  const keys = {};
  window.addEventListener('keydown', e=>{
    keys[e.key.toLowerCase()] = true;
    if(e.key === 'Tab'){ e.preventDefault(); e.stopPropagation(); interact(); return; }
    if(e.key===' '){ tryJump(); }
    if(e.shiftKey && e.key.toLowerCase()==='o'){ interact(); }
  });
  window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });

  function tryJump(){ if(onGround){ velocity.y = 700; onGround = false; } }

  // interaction
  function interact(){ let nearest=null, nd=Infinity; for(const c of chests){ const d=Math.hypot(player.position.x - c.x, player.position.z - c.z); if(d<nd && d<220){ nd=d; nearest=c; } } if(!nearest) return; if(nearest.collected){ const text = letters[nearest.id-1] || ''; showLetter(nearest.id, text); return; }
    if(nearest.id !== nextChest){ toast(`Chest ${nearest.id} locked. Need ${nextChest}`); return; }
    const qobj = qa[nearest.id-1] || { question: `Answer this to open chest ${nearest.id}`, answer: '' };
    askQuestion(nearest.id, qobj.question, qobj.answer, (ok) => {
      if(ok){
        nearest.collected=true; nearest.group.children[1].rotation.x=-0.9; foundCount++; nextChest = Math.min(20, nextChest+1); spawnParticlesAt(nearest.x, nearest.z, 24); const text = letters[nearest.id-1] || ''; showLetter(nearest.id, text); saveState(); refreshUI(); if(foundCount===20) toast('All chests collected — beautiful!'); 
      } else {
        toast('Incorrect — try again');
      }
    });
  }

  // question modal helper
  function askQuestion(id, question, answer, cb){
    const overlay=document.createElement('div'); Object.assign(overlay.style,{position:'fixed',inset:0,display:'flex',alignItems:'center',justifyContent:'center',background:'rgba(0,0,0,0.55)',zIndex:9999});
    const box=document.createElement('div'); box.style.cssText='background:#082a30;color:#fff;padding:18px;border-radius:12px;min-width:320px;max-width:86vw;max-height:86vh;overflow:auto;text-align:left';
    const title=document.createElement('div'); title.textContent = `Chest ${id} — Answer to open`; title.style.fontWeight='900'; title.style.marginBottom='8px';
    const qEl = document.createElement('div'); qEl.textContent = question; qEl.style.marginBottom='8px';
    const input = document.createElement('input'); input.type='text'; input.style.width='100%'; input.style.padding='8px'; input.style.borderRadius='8px'; input.value='';
    const hint = document.createElement('div'); hint.className='small-muted'; hint.textContent='Answer comparison is case-insensitive and whitespace-trimmed.'; hint.style.marginTop='6px';
    const row = document.createElement('div'); row.style.display='flex'; row.style.gap='8px'; row.style.marginTop='12px';
    const btnOk = document.createElement('button'); btnOk.textContent='Submit';
    const btnClose = document.createElement('button'); btnClose.textContent='Cancel';

    function cleanup(){ try{ input.removeEventListener('keydown', onKeyDown); }catch(_){} }
    btnOk.onclick = ()=>{ const val = (input.value||'').trim(); const ans = (answer||'').trim(); if(ans === ''){ if(val.length===0){ toast('Please type an answer'); return; } cleanup(); overlay.remove(); cb(true); return; } if(val.toLowerCase() === ans.toLowerCase()){ cleanup(); overlay.remove(); cb(true); } else { cleanup(); overlay.remove(); cb(false); } };
    btnClose.onclick = ()=>{ cleanup(); overlay.remove(); cb(false); };

    function onKeyDown(ev){ if(ev.key === 'Enter'){ ev.preventDefault(); btnOk.click(); } }
    input.addEventListener('keydown', onKeyDown);

    row.appendChild(btnOk); row.appendChild(btnClose);
    box.appendChild(title); box.appendChild(qEl); box.appendChild(input); box.appendChild(hint); box.appendChild(row);
    overlay.appendChild(box); document.body.appendChild(overlay);
    input.focus();
  }

  function showDialog(text, opts={tts:false, speed:32}){ dialogBox.style.display='block'; dialogBox.textContent=''; let i=0; const iv=setInterval(()=>{ dialogBox.textContent += text[i++]||''; if(i>text.length){ clearInterval(iv); setTimeout(()=> dialogBox.style.display='none',900); } }, 1000/opts.speed); }

  // showLetter updated: admin can edit letter inside modal regardless of page-level admin (but save will check admin)
  function showLetter(id, text){
    const overlay = document.createElement('div');
    Object.assign(overlay.style, { position:'fixed', inset:0, display:'flex', alignItems:'center', justifyContent:'center', background:'rgba(0,0,0,0.45)', zIndex:9999 });

    const box = document.createElement('div');
    box.style.cssText = 'background:#082a30;color:#fff;padding:18px;border-radius:12px;min-width:320px;max-width:86vw;max-height:86vh;overflow:auto;text-align:left';

    const title = document.createElement('div');
    title.textContent = `Chest ${id} opened`;
    title.style.fontWeight = '900';
    title.style.marginBottom = '8px';

    const quickEdit = document.createElement('textarea');
    quickEdit.rows = Math.min(20, Math.max(6, Math.ceil((text||'').length/120)));
    quickEdit.style.width = '100%';
    quickEdit.style.marginTop = '8px';
    quickEdit.value = text || '';

    const btnSave = document.createElement('button'); btnSave.textContent = 'Save & Close';
    const btnClose = document.createElement('button'); btnClose.textContent = 'Close';

    function cleanup(){ try{ quickEdit.removeEventListener('keydown', onQuickKey); } catch(_) {} try{ btnSave.removeEventListener('click', onSave); } catch(_) {} try{ btnClose.removeEventListener('click', onClose); } catch(_) {} }

    function onSave(){ if(!isAdmin){ toast('Admin only — changes will not be saved'); cleanup(); overlay.remove(); return; } letters[id-1] = quickEdit.value; saveState(); cleanup(); overlay.remove(); refreshUI(); if(foundCount === 20){ triggerFireworks(5000); } }
    function onClose(){ cleanup(); overlay.remove(); if(foundCount === 20){ triggerFireworks(5000); } }

    function onQuickKey(e){ if(e.key === 'Enter'){ e.preventDefault(); onSave(); } }

    btnSave.addEventListener('click', onSave);
    btnClose.addEventListener('click', onClose);
    quickEdit.addEventListener('keydown', onQuickKey);

    box.appendChild(title);
    box.appendChild(quickEdit);
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.gap = '8px';
    row.style.marginTop = '10px';
    row.appendChild(btnSave);
    row.appendChild(btnClose);
    box.appendChild(row);
    overlay.appendChild(box);
    document.body.appendChild(overlay);

    quickEdit.focus();
  }

  // GLTF loader + draco (unchanged)
  const gltfLoader = new GLTFLoader();
  const dracoLoader = new DRACOLoader();
  dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
  gltfLoader.setDRACOLoader(dracoLoader);

  let mixer = null, currentModel = null, actions = {}, activeAction = null;
  const defaultCandidates = [
    'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/WalkingLady/glTF-Binary/WalkingLady.glb',
    'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb'
  ];

  async function loadModelFromUrl(url){
    slog('Loading model: ' + url);
    return new Promise((resolve,reject)=>{
      gltfLoader.load(url, (g)=>resolve(g), (xhr)=>{ if(xhr && xhr.total) slog(`Model ${(xhr.loaded/xhr.total*100).toFixed(0)}%`); }, (err)=>reject(err));
    });
  }

  async function tryLoadDefaultModelSequence(){
    for(const u of defaultCandidates){ try{ const g = await loadModelFromUrl(u); setupModel(g); return; }catch(e){ slog('Candidate failed: ' + u); } }
    slog('No model loaded; staying with placeholder.');
  }

  function setupModel(gltf){
    if(currentModel){ player.remove(currentModel); currentModel.traverse(n=>{ if(n.isMesh) n.geometry?.dispose && n.geometry.dispose(); }); currentModel=null; mixer=null; actions={}; activeAction=null; }
    currentModel = gltf.scene || gltf.scenes[0];
    currentModel.traverse(n=>{ if(n.isMesh){ n.castShadow=true; n.receiveShadow=true; } });
    const bbox = new THREE.Box3().setFromObject(currentModel); const size = new THREE.Vector3(); bbox.getSize(size); const height = size.y||1; const scale = 140/(height||1);
    currentModel.scale.setScalar(scale * 1.25);
    currentModel.position.set(0,0,0);
    if(placeholder && placeholder.parent) player.remove(placeholder);
    player.add(currentModel);
    if(gltf.animations && gltf.animations.length){
      mixer = new THREE.AnimationMixer(currentModel);
      gltf.animations.forEach(clip=>{ actions[clip.name||clip.uuid] = mixer.clipAction(clip); });
      const names = Object.keys(actions);
      const idleName = names.find(n=>/idle/i.test(n))||names[0];
      const walkName = names.find(n=>/walk/i.test(n))||names.find(n=>/run/i.test(n))||names[0];
      for(const n of names){ actions[n].reset().play(); actions[n].enabled=true; actions[n].setEffectiveWeight(0); actions[n].paused=false; }
      activeAction = actions[idleName]; if(activeAction) activeAction.setEffectiveWeight(1);
      player.userData._animIdle = idleName; player.userData._animMove = walkName;
      slog('Animations: ' + names.join(', ') + ' (idle=' + idleName + ' move=' + walkName + ')');
    } else slog('Model has no animations.');
  }

  // resize
  function resizeRenderer(){ const leftRect = document.getElementById('left').getBoundingClientRect(); const w = Math.max(64, Math.floor(leftRect.width)); const h = Math.max(64, Math.floor(window.innerHeight)); renderer.setSize(w,h); camera.aspect = w/h; camera.updateProjectionMatrix(); }
  window.addEventListener('resize', resizeRenderer); requestAnimationFrame(resizeRenderer);

  // MAIN LOOP
  let last = performance.now();
  function mainLoop(now){
    try{
      const dt = Math.min(0.05, (now - last)/1000); last = now;

      const camQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(cameraPitch, cameraYaw, 0, 'YXZ'));
      const camForward = new THREE.Vector3(0,0,-1).applyQuaternion(camQuat).setY(0).normalize();
      const camRight = new THREE.Vector3().crossVectors(camForward, new THREE.Vector3(0,1,0)).normalize();

      let moveDir = new THREE.Vector3(0,0,0);
      if(keys['w'] || keys['arrowup']) moveDir.add(camForward);
      if(keys['s'] || keys['arrowdown']) moveDir.sub(camForward);
      if(keys['a'] || keys['arrowleft']) moveDir.sub(camRight);
      if(keys['d'] || keys['arrowright']) moveDir.add(camRight);
      const isMoving = moveDir.lengthSq() > 0;

      if(isMoving){ moveDir.normalize(); player.position.addScaledVector(moveDir, MOVE_SPEED * dt); const targetYaw = Math.atan2(moveDir.x, moveDir.z); const currentYaw = player.rotation.y || 0; let diff = targetYaw - currentYaw; diff = (diff + Math.PI) % (Math.PI*2) - Math.PI; const ROT_SPEED = 12; player.rotation.y = currentYaw + diff * Math.min(1, ROT_SPEED * dt); }

      const downRay = new THREE.Raycaster(new THREE.Vector3(player.position.x, 400, player.position.z), new THREE.Vector3(0,-1,0));
      const hits = downRay.intersectObject(ground);
      let groundY = -Infinity;
      if(hits.length) groundY = hits[0].point.y;
      if(player.position.y <= groundY + 40 + 0.1){ player.position.y = groundY + 40; velocity.y = 0; onGround = true; } else { onGround = false; velocity.y += GRAV * dt; player.position.y += velocity.y * dt; }

      if(placeholder) placeholder.position.y = Math.sin(walkTimer) * (isMoving ? 3 : 1.2);

      if(mixer){ mixer.update(dt); const idleName = player.userData._animIdle; const moveName = player.userData._animMove; if(idleName && moveName && actions[idleName] && actions[moveName]){ const idle = actions[idleName]; const move = actions[moveName]; const targetMoveWeight = isMoving ? 1 : 0; idle.setEffectiveWeight(THREE.MathUtils.lerp(idle.getEffectiveWeight(), 1 - targetMoveWeight, 0.12)); move.setEffectiveWeight(THREE.MathUtils.lerp(move.getEffectiveWeight(), targetMoveWeight, 0.12)); } }

      const camOffset = new THREE.Vector3(0, 220, cameraDistanceDefault);
      const camWorldOffset = camOffset.clone().applyQuaternion(camQuat);
      const desiredCamPos = new THREE.Vector3().copy(player.position).add(camWorldOffset);
      camera.position.lerp(desiredCamPos, 0.16);
      camera.lookAt(player.position.x, player.position.y + 20, player.position.z);

      ensureParticleMeshes(particles.length);
      for(let i=0;i<particlePool.length;i++){ const m = particlePool[i]; if(i < particles.length){ const p = particles[i]; m.visible = true; m.position.copy(p.pos); m.material.color.setHex(p.color); m.scale.setScalar(1 + (1 - Math.max(0, p.life)) * 1.2); } else m.visible = false; }
      for(let i=particles.length-1;i>=0;i--){ const p = particles[i]; p.life -= dt; p.vel.y -= 600*dt; p.pos.addScaledVector(p.vel, dt); if(p.life <= 0) particles.splice(i,1); }

      ensureHeartMeshes(heartParticles.length);
      for(let i=0;i<heartPool.length;i++){ const m = heartPool[i]; if(i < heartParticles.length){ const p = heartParticles[i]; m.visible = true; m.position.copy(p.pos); const s = p.scale || 1; m.scale.setScalar(s); m.material.opacity = Math.max(0, Math.min(1, p.life/2)); } else m.visible = false; }
      for(let i=heartParticles.length-1;i>=0;i--){ const p = heartParticles[i]; p.life -= dt; p.pos.addScaledVector(p.vel, dt); p.vel.x *= (1 - 0.01); p.vel.z *= (1 - 0.01); if(p.life <= 0) heartParticles.splice(i,1); }

      chests.forEach(c => { if(c.collected) c.group.children[1].rotation.x = THREE.MathUtils.lerp(c.group.children[1].rotation.x, -0.95, 0.12); });

      renderer.render(scene, camera);
      if(isMoving) walkTimer += dt * 8; else walkTimer += dt * 1;
    }catch(err){ slog('mainLoop error: ' + (err && err.stack ? err.stack : err)); }
    requestAnimationFrame(mainLoop);
  }
  requestAnimationFrame(mainLoop);

  // tooltip updater + chest-popup
  function updateTooltip(){ try{ let near=null, nd=Infinity; for(const c of chests){ if(c.collected) continue; const d=Math.hypot(player.position.x - c.x, player.position.z - c.z); if(d < nd && d < 300){ nd=d; near=c; } } if(near){ tooltipEl.style.display='block'; tooltipEl.textContent = `Chest ${near.id} ${near.id===nextChest? '— Press Tab to open' : '— Locked'}`;
      const v=new THREE.Vector3(near.x,30,near.z); v.project(camera);
      const rect=renderer.domElement.getBoundingClientRect();
      const left = rect.left + (v.x*0.5+0.5)*rect.width;
      const top = rect.top + (-v.y*0.5+0.5)*rect.height;
      tooltipEl.style.left = `${left}px`;
      tooltipEl.style.top = `${top}px`;
      if(nextPill) nextPill.style.display = 'none';

      if(chestPopup){
        chestPopup.style.display = 'block';
        chestPopup.querySelector('.num').textContent = String(near.id);
        const worldAbove = new THREE.Vector3(near.x, 48, near.z);
        const proj = worldAbove.project(camera);
        const px = rect.left + (proj.x*0.5+0.5)*rect.width;
        const py = rect.top + (-proj.y*0.5+0.5)*rect.height;
        chestPopup.style.left = px + 'px';
        chestPopup.style.top = py + 'px';
        chestPopup.style.transform = 'translate(-50%,-120%) scale(1.0)';
      }
    } else {
      tooltipEl.style.display='none';
      if(nextPill) nextPill.style.display = 'inline-block';
      if(chestPopup) chestPopup.style.display = 'none';
    } }catch(e){} requestAnimationFrame(updateTooltip); }
  updateTooltip();

  renderer.domElement.addEventListener('click', e=>{
    const rect = renderer.domElement.getBoundingClientRect();
    const sx = (e.clientX - rect.left) / rect.width * 2 - 1;
    const sy = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    const ray = new THREE.Raycaster();
    ray.setFromCamera(new THREE.Vector2(sx, sy), camera);
    const hits = ray.intersectObject(ground);
    if(hits.length){
      const p = hits[0].point;
      if(e.ctrlKey) player.position.set(p.x, p.y + 40, p.z);
    }
  });

  // init
  createChestTextareas();
  const loaded = loadState();
  refreshUI();
  tryLoadDefaultModelSequence();
  slog('Per-chest letters + Q/A build loaded. Admin=' + (isAdmin ? 'yes' : 'no') + '.');

  // -------------------------
  // Birthday popup logic
  // -------------------------
  (function setupBirthdayPopup(){
    const popup = document.getElementById('birthdayPopup');
    const closeBtn = document.getElementById('birthdayClose');
    function closePopup(){ if(!popup) return; popup.style.display = 'none'; popup.setAttribute('aria-hidden', 'true'); }
    closeBtn.addEventListener('click', closePopup);
    window.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') closePopup(); });
    setTimeout(()=>{ if(popup) { popup.style.display = 'flex'; popup.setAttribute('aria-hidden','false'); } }, 120);
  })();

  // final admin UI toggle
  (function applyAdminUI(){
    const side = document.getElementById('side');
    if(isAdmin){
      adminBadge.style.display='inline-block';
      readOnlyNote.style.display='none';
      saveBtn.style.display='inline-block';
      if(side) side.style.display = 'block';
    } else {
      adminBadge.style.display='none';
      readOnlyNote.style.display='block';
      saveBtn.style.display='none';
      // hide entire sidebar for non-admins
      if(side) side.style.display = 'none';
    }
  })();

  </script>
</body>
</html>
